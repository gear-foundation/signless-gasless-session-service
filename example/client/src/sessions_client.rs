// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::{client::*, collections::*, prelude::*};
pub struct SessionsClientProgram;
impl sails_rs::client::Program for SessionsClientProgram {}
pub trait SessionsClient {
    type Env: sails_rs::client::GearEnv;
    fn session(&self) -> sails_rs::client::Service<session::SessionImpl, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> SessionsClient
    for sails_rs::client::Actor<SessionsClientProgram, E>
{
    type Env = E;
    fn session(&self) -> sails_rs::client::Service<session::SessionImpl, Self::Env> {
        self.service(stringify!(Session))
    }
}
pub trait SessionsClientCtors {
    type Env: sails_rs::client::GearEnv;
    #[allow(clippy::new_ret_no_self)]
    #[allow(clippy::wrong_self_convention)]
    fn new(
        self,
        config: SessionConfig,
    ) -> sails_rs::client::PendingCtor<SessionsClientProgram, io::New, Self::Env>;
}
impl<E: sails_rs::client::GearEnv> SessionsClientCtors
    for sails_rs::client::Deployment<SessionsClientProgram, E>
{
    type Env = E;
    fn new(
        self,
        config: SessionConfig,
    ) -> sails_rs::client::PendingCtor<SessionsClientProgram, io::New, Self::Env> {
        self.pending_ctor((config,))
    }
}

pub mod io {
    use super::*;
    sails_rs::io_struct_impl!(New (config: super::SessionConfig) -> ());
}

pub mod session {
    use super::*;
    pub trait Session {
        type Env: sails_rs::client::GearEnv;
        fn create_session(
            &mut self,
            signature_data: SignatureData,
            signature: Option<Vec<u8>>,
        ) -> sails_rs::client::PendingCall<io::CreateSession, Self::Env>;
        fn delete_session_from_account(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::DeleteSessionFromAccount, Self::Env>;
        fn delete_session_from_program(
            &mut self,
            session_for_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::DeleteSessionFromProgram, Self::Env>;
        fn session_for_the_account(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::SessionForTheAccount, Self::Env>;
        fn sessions(&self) -> sails_rs::client::PendingCall<io::Sessions, Self::Env>;
    }
    pub struct SessionImpl;
    impl<E: sails_rs::client::GearEnv> Session for sails_rs::client::Service<SessionImpl, E> {
        type Env = E;
        fn create_session(
            &mut self,
            signature_data: SignatureData,
            signature: Option<Vec<u8>>,
        ) -> sails_rs::client::PendingCall<io::CreateSession, Self::Env> {
            self.pending_call((signature_data, signature))
        }
        fn delete_session_from_account(
            &mut self,
        ) -> sails_rs::client::PendingCall<io::DeleteSessionFromAccount, Self::Env> {
            self.pending_call(())
        }
        fn delete_session_from_program(
            &mut self,
            session_for_account: ActorId,
        ) -> sails_rs::client::PendingCall<io::DeleteSessionFromProgram, Self::Env> {
            self.pending_call((session_for_account,))
        }
        fn session_for_the_account(
            &self,
            account: ActorId,
        ) -> sails_rs::client::PendingCall<io::SessionForTheAccount, Self::Env> {
            self.pending_call((account,))
        }
        fn sessions(&self) -> sails_rs::client::PendingCall<io::Sessions, Self::Env> {
            self.pending_call(())
        }
    }

    pub mod io {
        use super::*;
        sails_rs::io_struct_impl!(CreateSession (signature_data: super::SignatureData, signature: Option<Vec<u8>>) -> ());
        sails_rs::io_struct_impl!(DeleteSessionFromAccount () -> ());
        sails_rs::io_struct_impl!(DeleteSessionFromProgram (session_for_account: ActorId) -> ());
        sails_rs::io_struct_impl!(SessionForTheAccount (account: ActorId) -> Option<super::SessionData>);
        sails_rs::io_struct_impl!(Sessions () -> Vec<(ActorId,super::SessionData,)>);
    }

    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum SessionEvents {
            SessionCreated,
            SessionDeleted,
        }
        impl sails_rs::client::Event for SessionEvents {
            const EVENT_NAMES: &'static [Route] = &["SessionCreated", "SessionDeleted"];
        }
        impl sails_rs::client::ServiceWithEvents for SessionImpl {
            type Event = SessionEvents;
        }
    }
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SessionConfig {
    pub gas_to_delete_session: u64,
    pub minimum_session_duration_ms: u64,
    pub ms_per_block: u64,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SignatureData {
    pub key: ActorId,
    pub duration: u64,
    pub allowed_actions: Vec<ActionsForSession>,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub enum ActionsForSession {
    StartGame,
    Move,
    Skip,
}
#[derive(PartialEq, Clone, Debug, Encode, Decode, TypeInfo)]
#[codec(crate = sails_rs::scale_codec)]
#[scale_info(crate = sails_rs::scale_info)]
pub struct SessionData {
    pub key: ActorId,
    pub expires: u64,
    pub allowed_actions: Vec<ActionsForSession>,
    pub expires_at_block: u32,
}
